import { PathGenerator, RoomPath } from "../interfaces/PathGenerator";
import { RoomFactory } from "../../factories/RoomFactory";
import { WallObjectFactory } from "../../factories/WallObjectFactory";
import { Edge } from "../../util/Graph";
import { Point } from "../../util/Point";
import { RoomType } from "../../enums/RoomType";
import { DoorType } from "../../enums/DoorType";
import { Door } from "../../interfaces/Door";
import { Room } from "../../interfaces/Room";
import { MersenneTwister } from "../../util/MersenneTwister";
import { XYMap } from "../../util/XYMap";
import { Orientation } from "../../enums/Orientation";
import { RoomUtils } from "../../util/RoomUtils";

// This can work for both Large and Small blob paths
export class BlobPathGenerator implements PathGenerator {

    // Maximum length of any straight portion of the hallways generated by this
    blobSizeFactor: number;
    roomFactory: RoomFactory;
    wallObjectFactory: WallObjectFactory;
    mersenneTwister: MersenneTwister;

    constructor(blobSizeFactor: number, roomFactory: RoomFactory, wallObjectFactory: WallObjectFactory, mersenneTwister: MersenneTwister) {
        this.blobSizeFactor = blobSizeFactor;
        this.roomFactory = roomFactory;
        this.wallObjectFactory = wallObjectFactory;
        this.mersenneTwister = mersenneTwister;
    }

    roomWalk(edge: Edge) : RoomPath {

        let destinationX = edge.p2.x,
            destinationY = edge.p2.y,
            x = edge.p1.x,
            y = edge.p1.y,
            nextX = x,
            nextY = y,
            pointMap: XYMap = new XYMap(),
            points: Array<Point> = [],
            rooms: Array<Room> = [],
            dx = destinationX - x,
            dy = destinationY - y,
            isFirstPass = true;

        // build initial door.
        let firstDoor: Door;
        if (Math.abs(dx) > Math.abs(dy)) {
            let mx = (dx > 0) ? 1 : -1;
            firstDoor = this.wallObjectFactory.buildDoor(x, y, x + mx, y, DoorType.STANDARD);
        } else {
            let my = (dy > 0) ? 1 : -1;
            firstDoor = this.wallObjectFactory.buildDoor(x, y, x, y + my, DoorType.STANDARD);
        }

        // check if these edges are already adjacent. If so, just return initial door and were done.
        if (Math.abs(dx) + Math.abs(dy) == 1) {
            return new RoomPath([], firstDoor, firstDoor);
        }

        // set the origin and destination in the pointMap so we don't overwrite it.
        pointMap.set(x, y);
        pointMap.set(destinationX, destinationY);

        // initialize our blob path. Set the direction we will go in to the longer axis.
        // set the starting points as our "lastPoint"
        let pointsAndLastPoint: PointsAndLastPoint = new PointsAndLastPoint([edge.p1], [edge.p1], edge.p1),
            direction: Orientation;
        if (Math.abs(dx) > Math.abs(dy)) direction = Orientation.HORIZONTAL;
        else direction = Orientation.VERTICAL;

        let lastRoomX = x,
            lastRoomY = y,
            lastRoom: Room | undefined,
            thisRoom: Room;
        while (true) {
            let nextStartingPoint: Point = this.selectNextBlobPoint(pointsAndLastPoint, destinationX, destinationY, direction),
                step: number; // store the last step as well as last direction
            // we need to calculate these again, using the "nextStartingPoint" coordinate
            // we have determined.
            x = nextStartingPoint.x;
            y = nextStartingPoint.y;
            dx = destinationX - x;
            dy = destinationY - y;

            if (!isFirstPass) {
                let thisRoom: Room = this.roomFactory.buildRoom(pointsAndLastPoint.points, RoomType.STANDARD);
                rooms.push(thisRoom);

                // The very first door is already handled before the loop, so just add it here.
                if (lastRoom == null) {
                    thisRoom.addDoor(firstDoor);
                } else {
                    this.buildDoor(lastRoom, lastRoomX, lastRoomY, thisRoom, x, y, DoorType.STANDARD);
                }
                lastRoom = thisRoom;

                // What will end up happening, is that for each axis, we will be one before the destination.
                // and then the nextStartingPoint will take us that final step to the destination on that axis.
                // So we will stop right before the destination, and then the next starting point will take us
                // onto the destination. So we don't want to add the next starting point.
                if (dx == 0 && dy == 0) {
                    break;
                }
            }
            isFirstPass = false;

            // we want to go within 1 distance from the destination, so when we select the next point
            // it will be in the above special case.
            let stepsToTake: number,
                orientation: Orientation;
            if (Math.abs(dx) > Math.abs(dy)) {
                direction = Orientation.HORIZONTAL;
                step = (dx > 0) ? 1 : -1;
                // if the distance we have to travel is less than our maximum distance,
                // only travel the maximum distance
                if (Math.abs(dx) <= this.blobSizeFactor) {
                    // attempt to go to within 1 of the X coordinate if its within reach
                    // calculate1ShortOfDestinationX
                    // subtract step to ensure we end up 1 short of the destination.
                    stepsToTake = this.stepsTo1ShortOfDestination(x, destinationX);
                } else {
                    // otherwise just go the maximum distance in this direction
                    stepsToTake = this.blobSizeFactor;
                }
            } else {
                direction = Orientation.VERTICAL;
                step = (dy > 0) ? 1 : -1;
                if (Math.abs(dy) <= this.blobSizeFactor) {
                    stepsToTake = this.stepsTo1ShortOfDestination(y, destinationY);
                } else {
                    stepsToTake = this.blobSizeFactor;
                }
            }
            // if we are one away, the next blobStartingPoint will get us to our destination.
            if (stepsToTake != 0) {
                pointsAndLastPoint = this.blobWalkAxis(x, y, direction, step, stepsToTake, this.blobSizeFactor, pointMap, this.mersenneTwister);
            } else {
                // construct our pointsAndLastPoint object from just the nextStartingPoint to keep
                // things moving forward.
                pointsAndLastPoint = new PointsAndLastPoint([nextStartingPoint], [nextStartingPoint], nextStartingPoint);
            }

        }

        let lastPoint = pointsAndLastPoint.lastOnAxisPoint,
            lastDoor: Door = this.wallObjectFactory.buildDoor(lastPoint.x, lastPoint.y, destinationX, destinationY, DoorType.STANDARD);
        lastRoom.addDoor(lastDoor);


        // TODO: need a test to ensure the first and last rooms are linked correctly with the first and last door
        return new RoomPath(rooms, firstDoor, lastDoor);
    }

    buildDoor(lastRoom: Room, lastRoomX: number, lastRoomY: number, thisRoom: Room, x: number, y: number, doorType: DoorType) : void {
        let connections: XYMap = RoomUtils.calculateEdgesBetweenRooms(lastRoom, thisRoom);
        // TODO: for now we are just selecting the first connection.

        if (connections.getPoints().length == 0)  throw "No connections between rooms: " + lastRoom + "  " + thisRoom;

        let point1: Point = <Point> connections.getPoints()[0],
            point2: Point = point1.value[0],
            door: Door = this.wallObjectFactory.buildDoor(point1.x, point1.y, point2.x, point2.y, doorType);
        if (lastRoom != null) {
            lastRoom.addDoor(door);
        }
        thisRoom.addDoor(door);
    }

    /**
     * Calculates the number of steps to be 1 away from the destination
     */
    stepsTo1ShortOfDestination(n: number, destination: number) : number {
        if (destination > n) {
            return destination - 1 - n;
        }
        return n - (destination + 1);
    }

    /**
     * This is always going to be the lastOnAxisPoint's x or y, +/- 1 depending on the direction
     * to the destination.
     */
    selectNextBlobPoint(pointsAndLastPoints: PointsAndLastPoint, destinationX: number, destinationY: number, lastDirection: Orientation) : Point {
        // TODO: something is messed up here i think.
        let nextPoint: Point,
            lastOnAxisPoint = pointsAndLastPoints.lastOnAxisPoint;
        if (lastDirection == Orientation.VERTICAL) {
            if (destinationY > lastOnAxisPoint.y) 
                nextPoint = new Point(lastOnAxisPoint.x, lastOnAxisPoint.y + 1);
            else 
                nextPoint = new Point(lastOnAxisPoint.x, lastOnAxisPoint.y - 1);
        } else {
            if (destinationX > lastOnAxisPoint.x) 
                nextPoint = new Point(lastOnAxisPoint.x + 1, lastOnAxisPoint.y);
            else 
                nextPoint = new Point(lastOnAxisPoint.x - 1, lastOnAxisPoint.y);
        }
        return nextPoint;
    }

    // Fills in the points from starting at x,y, travelling along the axis specified
    // and taking the provided number of steps in the direction of step (+ or -).
    //
    // includes x,y in the points.
    blobWalkAxis(x: number, y: number, axis: Orientation, step: number, steps: number, blobSizeFactor: number, pointMap: XYMap, mersenneTwister: MersenneTwister) : PointsAndLastPoint {
        if (steps < 1) throw "invalid number of steps passed";

        let points: Array<Point> = [],
            // for checkstyle, these will always get replaced.
            lastPoint: Point = new Point(-9999999999999,-9999999999999),
            lastOnAxisPoint: Point = new Point(-9999999999,-999999999999),
            pointsAndLastPoint: PointsAndLastPoint = new PointsAndLastPoint([], [], lastOnAxisPoint);
        points.push(new Point(x, y));
        pointMap.set(x, y);
        if (axis == Orientation.VERTICAL) {
            // we are walking along the Y axis, so blobify horizontally
            for (let i = 0;i < steps; i++) {
                y += step;
                pointsAndLastPoint = this.horizontalBlobify(x, y, blobSizeFactor, pointMap, mersenneTwister);
                for (let point of pointsAndLastPoint.points) {
                    points.push(point);
                    pointMap.set(point.x, point.y);
                }
            }
        } else {
            for (let i = 0;i < steps; i++) {
                // walking along the X axis, so blobify vertically
                x += step;
                pointsAndLastPoint = this.verticalBlobify(x, y, blobSizeFactor, pointMap, mersenneTwister);
                for (let point of pointsAndLastPoint.points) {
                    points.push(point);
                    pointMap.set(point.x, point.y);
                }
            }
        }

        return new PointsAndLastPoint(points, pointsAndLastPoint.lastPoints, pointsAndLastPoint.lastOnAxisPoint);
    }

    // blobify along the vertical axis
    verticalBlobify(x: number, y: number, blobSizeFactor: number, pointMap: XYMap, mersenneTwister: MersenneTwister) : PointsAndLastPoint {
        let yTop = y,
            yBottom = y,
            lastY = y,
            points: Array<Point> = [],
            cancelChance = 0,
            cancelFactor = .75 / blobSizeFactor;
        points.push(new Point(x, y));
        pointMap.set(x, y);
        for (let i = 0; i < blobSizeFactor; i++ ) {
            if (mersenneTwister.genrand_rangeDecimal(0, 1) < cancelChance) {
                break;
            }
            cancelChance += cancelFactor;

            if (mersenneTwister.genrand_rangeDecimal(0, 2) > 1) {
                if (pointMap.get(x, yTop + 1) != undefined) continue;
                yTop++;
                lastY = yTop;
                points.push(new Point(x, yTop));
                pointMap.set(x, yTop);
            } else {
                if (pointMap.get(x, yBottom - 1) != undefined) continue;
                yBottom--;
                lastY = yBottom;
                points.push(new Point(x, yBottom));
                pointMap.set(x, yBottom);
            }
        }
        return new PointsAndLastPoint(points, points, new Point(x, y));
    }

    // blobify along the x axis.
    horizontalBlobify(x: number, y: number, blobSizeFactor: number, pointMap: XYMap, mersenneTwister: MersenneTwister) : PointsAndLastPoint {
        let xLeft = x,
            xRight = x,
            lastX = x,
            points: Array<Point> = [],
            cancelChance = 0,
            cancelFactor = .75 / blobSizeFactor;
        points.push(new Point(x, y));
        pointMap.set(x, y);
        for (let i = 0; i < blobSizeFactor; i++ ) {
            if (mersenneTwister.genrand_rangeDecimal(0, 1) < cancelChance) {
                break;
            }
            cancelChance += cancelFactor;

            if (mersenneTwister.genrand_rangeDecimal(0, 2) > 1) {
                if (pointMap.get(xLeft - 1, y) != undefined) continue;
                xLeft--;
                lastX = xLeft;
                points.push(new Point(xLeft, y));
                pointMap.set(xLeft, y);
            } else {
                if (pointMap.get(xRight + 1, y) != undefined) continue;
                xRight++;
                lastX = xRight;
                points.push(new Point(xRight, y));
                pointMap.set(xRight, y);
            }
        }
        return new PointsAndLastPoint(points, points, new Point(x, y));
    }
}

// Convenience class to group a commonly returned object in the blob generator.
// the points are points generated by a method, with the last point specified
export class PointsAndLastPoint {
    points: Array<Point>;
    lastPoints: Array<Point>;
    lastOnAxisPoint: Point;
    constructor(points: Array<Point>, lastPoints: Array<Point>, lastOnAxisPoint: Point) {
        this.points = points;
        this.lastPoints = lastPoints;
        this.lastOnAxisPoint = lastOnAxisPoint;
    }
}
